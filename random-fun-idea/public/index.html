<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Fun Idea</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Inter font for general text -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Nanum Pen Script font for specific Korean text -->
  <link href="https://fonts.googleapis.com/css2?family=Nanum+Pen+Script&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f0f4f8; /* Light gray background */
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }
    .container {
      background-color: #ffffff;
      border-radius: 1.5rem; /* More rounded corners */
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      padding: 2.5rem;
      text-align: center;
      max-width: 600px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 2rem;
      animation: fadeIn 0.8s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .app-title-korean {
      font-family: 'Nanum Pen Script', cursive; /* Apply Nanum Pen Script */
      font-size: 2.5rem; /* Adjust size if needed for readability */
      line-height: 1.2;
    }
    .idea-display {
      min-height: 120px; /* Ensure consistent height */
      display: flex;
      flex-direction: column; /* Allow stacking of Korean and English */
      justify-content: center;
      align-items: center;
      font-size: 1.75rem; /* Larger font size */
      font-weight: 600;
      color: #333;
      line-height: 1.4;
      transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
      opacity: 1;
      transform: translateY(0);
      margin-bottom: 1rem; /* Space between idea and description */
    }
    .idea-display .korean {
      font-size: 1.75rem;
      font-weight: 600;
    }
    .idea-display .english {
      font-size: 1.25rem;
      font-weight: 400;
      color: #555;
      margin-top: 0.5rem;
    }
    .idea-description {
      min-height: 60px; /* Consistent height for description */
      font-size: 1rem;
      color: #666;
      line-height: 1.5;
      transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
      opacity: 1;
      transform: translateY(0);
      display: flex;
      flex-direction: column; /* Allow stacking of Korean and English */
      justify-content: center;
      align-items: center;
    }
    .idea-description .korean {
      font-size: 1rem;
      font-weight: 400;
    }
    .idea-description .english {
      font-size: 0.875rem;
      font-weight: 300;
      color: #777;
      margin-top: 0.25rem;
    }
    .fade-out {
      opacity: 0;
      transform: translateY(20px);
    }
    .fade-in {
      opacity: 1;
      transform: translateY(0);
    }
    .refresh-button {
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%); /* Gradient background */
      color: white;
      padding: 1rem 2rem;
      border-radius: 9999px; /* Pill shape */
      font-weight: 700;
      font-size: 1.125rem;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      outline: none;
    }
    .refresh-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }
    .refresh-button:active {
      transform: translateY(0);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
    }
    /* Styles for the lightbulb spinner */
    .loading-lightbulb {
      width: 80px; /* Make it larger */
      height: 80px;
      color: #2575fc; /* Color of the lightbulb */
      animation: spin 1.5s linear infinite; /* Slower spin */
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NXEW5H90P4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-NXEW5H90P4');
</script>
</head>
<body>
  <div class="container">
    <h1 class="text-4xl font-bold text-gray-800 mb-4">
      Random Fun Idea<br />
      <span class="app-title-korean">기발하고 재밌는 아이디어 생성기 ^^;</span>
    </h1>
    <div id="ideaDisplay" class="idea-display">
      <!-- Lightbulb loading spinner -->
      <svg class="loading-lightbulb" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19c-3.87 0-7 3.13-7 7 0 2.88 1.77 5.34 4.3 6.45.14.06.2.22.2.38v.67c0 .09.07.16.16.16h.68c.09 0 .16-.07.16-.16v-.67c0-.16.06-.32.2-.38C15.23 14.34 17 11.88 17 9c0-3.87-3.13-7-7-7zm0 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/>
      </svg>
    </div>
    <div id="ideaDescription" class="idea-description">
      <span class="korean">아이디어 설명을 불러오는 중...</span>
      <span class="english">Loading idea description...</span>
    </div>
    <button id="refreshButton" class="refresh-button">
      새로운 아이디어! (New Idea!)
    </button>
  </div>

  <script>
    const ideaDisplay = document.getElementById('ideaDisplay');
    const ideaDescription = document.getElementById('ideaDescription');
    const refreshButton = document.getElementById('refreshButton');

    const apiKey = ""; // Canvas will automatically provide the API key
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

    // Store the last 50 unique keywords to prevent immediate duplicates
    let keywordHistory = [];
    const MAX_KEYWORD_HISTORY_SIZE = 50;
    const MAX_FETCH_RETRIES = 5; // Max attempts to get a unique keyword or idea from API

    // Function to fetch a single random keyword from Gemini API
    async function _fetchSingleKeywordFromGemini() {
      try {
        const prompt = "Give me one single, random, abstract keyword in Korean. Respond only with the keyword itself, no greetings or extra text.";
        const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
        const payload = { contents: chatHistory };

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
          return result.candidates[0].content.parts[0].text.trim();
        }
        return ""; // Return empty string if no keyword
      } catch (error) {
        console.error("Error fetching keyword:", error);
        return ""; // Handle error gracefully
      }
    }

    // Function to fetch a unique keyword from Gemini API
    async function fetchUniqueKeyword() {
      let keyword = null;
      let isUnique = false;
      let retries = 0;

      while (!isUnique && retries < MAX_FETCH_RETRIES) {
        keyword = await _fetchSingleKeywordFromGemini();
        if (keywordHistory.includes(keyword)) {
          console.log("Duplicate keyword found, retrying...");
          retries++;
        } else {
          isUnique = true;
        }
      }

      // If after retries, still not unique, use the last fetched keyword
      if (!isUnique && keyword) {
        console.warn("Max retries reached for keyword, displaying potentially duplicate keyword.");
      } else if (!keyword) {
        // Fallback if keyword fetching completely fails
        keyword = "상상"; // Default keyword
      }

      // Add the unique (or last fetched) keyword to history
      if (keyword && !keywordHistory.includes(keyword)) { // Ensure we don't add if it was already in history (e.g., after retries)
        keywordHistory.push(keyword);
        // Keep history size limited
        if (keywordHistory.length > MAX_KEYWORD_HISTORY_SIZE) {
          keywordHistory.shift(); // Remove the oldest keyword
        }
      }
      return keyword;
    }

    // Function to fetch a new idea and its description from Gemini API, using a keyword
    async function fetchIdeaFromGemini(keyword) {
      try {
        let chatHistory = [];
        // Base prompt for the idea and description.
        let basePrompt = "please give me one single, short, ridiculous, quirky, and fun idea, along with a brief, creative explanation for it. Provide both the idea and explanation in Korean first, followed by their English translations. The idea should be concise, and the explanation should be 1-2 sentences. Respond only with JSON in the format: {\"idea_ko\": \"아이디어 내용 (한국어)\", \"idea_en\": \"Idea content (English)\", \"description_ko\": \"설명 내용 (한국어)\", \"description_en\": \"Description content (English)\"}";
        
        // Append keyword to encourage diverse responses
        const prompt = `Regarding this keyword, ${keyword}, ${basePrompt}`;
        
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });

        const payload = {
          contents: chatHistory,
          generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
              type: "OBJECT",
              properties: {
                "idea_ko": { "type": "STRING" },
                "idea_en": { "type": "STRING" },
                "description_ko": { "type": "STRING" },
                "description_en": { "type": "STRING" }
              },
              "propertyOrdering": ["idea_ko", "idea_en", "description_ko", "description_en"]
            }
          }
        };

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
          const jsonString = result.candidates[0].content.parts[0].text;
          console.log("Raw JSON string from Gemini:", jsonString); // Log raw JSON for debugging
          try {
            const parsedJson = JSON.parse(jsonString);
            return parsedJson; // Return the parsed JSON object
          } catch (jsonError) {
            console.error("Error parsing JSON from Gemini API:", jsonError);
            console.error("Malformed JSON received:", jsonString);
            return {
              idea_ko: "아이디어 파싱 오류.",
              idea_en: "Idea parsing error.",
              description_ko: "잘못된 응답 형식입니다. 다시 시도해주세요.",
              description_en: "Malformed response format. Please try again."
            };
          }
        } else {
          console.error("Gemini API response structure unexpected:", result);
          return {
            idea_ko: "아이디어를 불러오지 못했습니다.",
            idea_en: "Failed to load idea.",
            description_ko: "다시 시도해주세요.",
            description_en: "Please try again."
          };
        }
      } catch (error) {
        console.error("Error fetching idea from Gemini API:", error);
        return {
          idea_ko: "아이디어를 불러오는 중 오류가 발생했습니다.",
          idea_en: "Error loading idea.",
          description_ko: "네트워크 연결을 확인하거나 잠시 후 다시 시도해주세요.",
          description_en: "Please check your network connection or try again later."
        };
      }
    }

    // Function to display a new idea and description with animation
    async function displayNewIdea() {
      // Add fade-out class to both elements
      ideaDisplay.classList.add('fade-out');
      ideaDescription.classList.add('fade-out');
      refreshButton.disabled = true; // Disable button during fetch

      // Display lightbulb spinner
      ideaDisplay.innerHTML = `
        <svg class="loading-lightbulb" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
          <path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19c-3.87 0-7 3.13-7 7 0 2.88 1.77 5.34 4.3 6.45.14.06.2.22.2.38v.67c0 .09.07.16.16.16h.68c.09 0 .16-.07.16-.16v-.67c0-.16.06-.32.2-.38C15.23 14.34 17 11.88 17 9c0-3.87-3.13-7-7-7zm0 10c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/>
        </svg>
      `;
      ideaDescription.innerHTML = '<span class="korean">아이디어 설명을 불러오는 중...</span><span class="english">Loading idea description...</span>';


      // After fade-out, update content and fade-in
      setTimeout(async () => {
        const keyword = await fetchUniqueKeyword(); // Fetch a unique keyword first
        const fetchedIdea = await fetchIdeaFromGemini(keyword); // Then fetch idea using the keyword

        // Update display with the fetched idea and description
        ideaDisplay.innerHTML = `<span class="korean">${fetchedIdea.idea_ko}</span><span class="english">${fetchedIdea.idea_en}</span>`;
        ideaDescription.innerHTML = `<span class="korean">${fetchedIdea.description_ko}</span><span class="english">${fetchedIdea.description_en}</span>`;

        // Remove fade-out and add fade-in classes
        ideaDisplay.classList.remove('fade-out');
        ideaDescription.classList.remove('fade-out');
        ideaDisplay.classList.add('fade-in');
        ideaDescription.classList.add('fade-in');
        refreshButton.disabled = false; // Re-enable button
      }, 500); // Match this duration with CSS transition duration
    }

    // Initial display of an idea when the page loads
    window.onload = function() {
      displayNewIdea();
      // Remove fade-in class after initial display to allow subsequent animations
      setTimeout(() => {
        ideaDisplay.classList.remove('fade-in');
        ideaDescription.classList.remove('fade-in');
      }, 1000);
    };

    // Event listener for the refresh button
    refreshButton.addEventListener('click', displayNewIdea);
  </script>
</body>
</html>
